package net.orekyuu.iroha.datasource;

import net.orekyuu.iroha.ThrowableConsumer;
import net.orekyuu.iroha.ThrowableFunction;
import net.orekyuu.iroha.adaptor.StatementAdaptor;
import net.orekyuu.iroha.delegators.StatementExecuteUpdateDelegator;
import net.orekyuu.iroha.util.ForceExecutor;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class IrohaStatement<T extends Statement> extends StatementAdaptor {
    protected final List<T> statements;
    protected final IrohaConnection connection;
    final StatementExecuteUpdateDelegator<T> executeUpdateDelegator;

    public IrohaStatement(List<T> statements, IrohaConnection connection) {
        this.statements = statements;
        this.connection = connection;
        this.executeUpdateDelegator = new StatementExecuteUpdateDelegator<>(statements);
    }

    protected final  <R> List<R> delegate(ThrowableFunction<T, R, SQLException> func) throws SQLException {
        List<R> results = new ArrayList<>();
        for (T statement : statements) {
            results.add(func.apply(statement));
        }
        return results;
    }

    protected final void delegate(ThrowableConsumer<T, SQLException> func) throws SQLException {
        for (T statement : statements) {
            func.accept(statement);
        }
    }

    protected final <R> R delegateOnlyOneStatement(ThrowableFunction<T, R, SQLException> func) throws SQLException {
        if (statements.size() != 1) {
            throw new SQLException("Only one statement expected");
        }
        return func.apply(statements.get(0));
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        ArrayList<ResultSet> results = new ArrayList<>();
        for (T statement : statements) {
            results.add(statement.getResultSet());
        }
        return new IrohaResultSet(results, this);
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        ArrayList<ResultSet> results = new ArrayList<>();
        for (T statement : statements) {
            results.add(statement.getGeneratedKeys());
        }
        return new IrohaResultSet(results, this);
    }

    @Override
    public IrohaConnection getConnection() {
        return connection;
    }

    @Override
    public void close() throws SQLException {
        ForceExecutor.execute(statements, Statement::close);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        return delegate(st -> {
            return st.execute(sql);
        }).stream().anyMatch(it -> it);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return delegate(st -> {
            return st.execute(sql, autoGeneratedKeys);
        }).stream().anyMatch(it -> it);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return delegate(st -> {
            return st.execute(sql, columnIndexes);
        }).stream().anyMatch(it -> it);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return delegate(st -> {
            return st.execute(sql, columnNames);
        }).stream().anyMatch(it -> it);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdateDelegator.delegate(st -> st.executeUpdate(sql));
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdateDelegator.delegate(st -> st.executeUpdate(sql, columnIndexes));
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdateDelegator.delegate(st -> st.executeUpdate(sql, columnNames));
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdateDelegator.delegate(st -> st.executeUpdate(sql, autoGeneratedKeys));
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        ArrayList<ResultSet> results = new ArrayList<>();
        for (Statement statement : statements) {
            results.add(statement.executeQuery(sql));
        }
        return new IrohaResultSet(results, this);
    }

    @Override
    public int getUpdateCount() throws SQLException {
        List<Integer> results = delegate(Statement::getUpdateCount);
        long nonResultCount = results.stream().filter(r -> r < 0).count();
        // when everything -1
        if (nonResultCount == results.size()) {
            return -1;
        }
        // when everything return update counts.
        return results.stream()
                .map(it -> Math.max(0, it)) // when cannot be updated, set to 0
                .reduce(0, Integer::sum);
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        delegate((T st) -> st.setFetchSize(rows));
    }

    @Override
    public int getFetchSize() throws SQLException {
        return delegateOnlyOneStatement(Statement::getFetchSize);
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        delegate((T st) -> st.setQueryTimeout(seconds));
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        return delegateOnlyOneStatement(Statement::getQueryTimeout);
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        delegate((T st) -> st.setMaxRows(max));
    }

    @Override
    public int getMaxRows() throws SQLException {
        return delegateOnlyOneStatement(Statement::getMaxRows);
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        delegate((T st) -> st.setPoolable(poolable));
    }

    @Override
    public boolean isPoolable() throws SQLException {
        return delegateOnlyOneStatement(Statement::isPoolable);
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
        delegate((T st) -> st.setMaxFieldSize(max));
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        return delegateOnlyOneStatement(Statement::getMaxFieldSize);
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        delegate((T st) -> st.setEscapeProcessing(enable));
    }

    @Override
    public void cancel() throws SQLException {
        delegate(Statement::cancel);
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        List<SQLWarning> warnings = delegate(Statement::getWarnings);
        return warnings.stream()
                .filter(Objects::nonNull)
                .reduce((a, b) -> {
                    b.setNextWarning(a);
                    return b;
                })
                .orElse(null);
    }

    @Override
    public void clearWarnings() throws SQLException {
        delegate(Statement::clearWarnings);
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        delegate((T st) -> st.setFetchDirection(direction));
    }

    @Override
    public int getFetchDirection() throws SQLException {
        return delegateOnlyOneStatement(Statement::getFetchDirection);
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        delegate((T st) -> st.setCursorName(name));
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        return false;
    }
}
