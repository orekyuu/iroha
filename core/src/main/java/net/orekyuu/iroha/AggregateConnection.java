package net.orekyuu.iroha;

import java.sql.*;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;
import net.orekyuu.iroha.delegate.CreateStatementDelegator;
import net.orekyuu.iroha.delegate.ExecuteAllMethodSafelyDelegator;
import net.orekyuu.iroha.delegate.SQLWarningDelegator;

public class AggregateConnection extends WrapAdaptor implements Connection {
  private final List<Connection> connections;
  private final SQLWarningDelegator<Connection> sqlWarningDelegator;
  private final CreateStatementDelegator createStatementDelegator;
  private final ExecuteAllMethodSafelyDelegator<Connection> executeAllMethodSafelyDelegator;

  public AggregateConnection(List<Connection> connections) {
    this.connections = connections;
    this.sqlWarningDelegator = new SQLWarningDelegator<>(connections, Connection::getWarnings);
    this.createStatementDelegator = new CreateStatementDelegator(connections, this);
    this.executeAllMethodSafelyDelegator = new ExecuteAllMethodSafelyDelegator<>(connections);
  }

  @Override
  public SQLWarning getWarnings() throws SQLException {
    return sqlWarningDelegator.getSQLWarnings();
  }

  @Override
  public void clearWarnings() throws SQLException {
    executeAllMethodSafelyDelegator.executeSafely(Connection::clearWarnings);
  }

  @Override
  public Statement createStatement() throws SQLException {
    return createStatementDelegator.delegate(Connection::createStatement);
  }

  @Override
  public Statement createStatement(int resultSetType, int resultSetConcurrency)
      throws SQLException {
    return createStatementDelegator.delegate(
        st -> st.createStatement(resultSetType, resultSetConcurrency));
  }

  @Override
  public Statement createStatement(
      int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
    return createStatementDelegator.delegate(
        st -> st.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability));
  }

  @Override
  public PreparedStatement prepareStatement(
      String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
      throws SQLException {
    throw new TodoException();
  }

  @Override
  public PreparedStatement prepareStatement(String sql) throws SQLException {
    throw new TodoException();
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
    throw new TodoException();
  }

  @Override
  public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
    throw new TodoException();
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
    throw new TodoException();
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
      throws SQLException {
    throw new TodoException();
  }

  @Override
  public CallableStatement prepareCall(String sql) throws SQLException {
    throw new TodoException();
  }

  @Override
  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency)
      throws SQLException {
    throw new TodoException();
  }

  @Override
  public CallableStatement prepareCall(
      String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
      throws SQLException {
    throw new TodoException();
  }

  @Override
  public String nativeSQL(String sql) throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void close() throws SQLException {
    executeAllMethodSafelyDelegator.executeSafely(Connection::close);
  }

  @Override
  public boolean isClosed() throws SQLException {
    for (Connection connection : connections) {
      if (!connection.isClosed()) {
        return false;
      }
    }
    return true;
  }

  @Override
  public String getSchema() throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void setSchema(String schema) throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getCatalog() throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void setCatalog(String catalog) throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void setClientInfo(Properties properties) throws SQLClientInfoException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void setClientInfo(String name, String value) throws SQLClientInfoException {
    throw new UnsupportedOperationException();
  }

  @Override
  public Properties getClientInfo() throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public String getClientInfo(String name) throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean isValid(int timeout) throws SQLException {
    for (Connection connection : connections) {
      if (!connection.isValid(timeout)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public boolean isReadOnly() throws SQLException {
    for (Connection connection : connections) {
      if (!connection.isReadOnly()) {
        return false;
      }
    }
    return true;
  }

  @Override
  public void setReadOnly(boolean readOnly) throws SQLException {
    executeAllMethodSafelyDelegator.executeSafely(c -> c.setReadOnly(readOnly));
  }

  @Override
  public DatabaseMetaData getMetaData() throws SQLException {
    throw new UnsupportedOperationException();
  }

  @Override
  public void abort(Executor executor) throws SQLException {
    executeAllMethodSafelyDelegator.executeSafely(c -> c.abort(executor));
  }

  // transaction methods
  @Override
  public void commit() throws SQLException {
    executeAllMethodSafelyDelegator.executeSafely(Connection::commit);
  }

  @Override
  public void rollback() throws SQLException {
    executeAllMethodSafelyDelegator.executeSafely(Connection::commit);
  }

  @Override
  public void rollback(Savepoint savepoint) throws SQLException {
    throw new TodoException();
  }

  @Override
  public Savepoint setSavepoint() throws SQLException {
    throw new TodoException();
  }

  @Override
  public Savepoint setSavepoint(String name) throws SQLException {
    throw new TodoException();
  }

  @Override
  public void releaseSavepoint(Savepoint savepoint) throws SQLException {
    throw new TodoException();
  }

  @Override
  public void setAutoCommit(boolean autoCommit) throws SQLException {
    throw new TodoException();
  }

  @Override
  public boolean getAutoCommit() throws SQLException {
    throw new TodoException();
  }

  @Override
  public int getTransactionIsolation() throws SQLException {
    throw new TodoException();
  }

  @Override
  public void setTransactionIsolation(int level) throws SQLException {
    throw new TodoException();
  }

  // Not supported.
  @Override
  public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public int getNetworkTimeout() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public SQLXML createSQLXML() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public NClob createNClob() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public Blob createBlob() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public Clob createClob() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public Map<String, Class<?>> getTypeMap() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public void setHoldability(int holdability) throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }

  @Override
  public int getHoldability() throws SQLException {
    throw new SQLFeatureNotSupportedException();
  }
}
